@page "/game/king"
@using PoCoupleQuiz.Core.Models
@using PoCoupleQuiz.Core.Services
@using Microsoft.AspNetCore.Components
@using MudBlazor
@using System.Text.Json
@using System.Timers
@using Microsoft.Extensions.Logging // Added Logging
@using System.Runtime.CompilerServices
@using PoCoupleQuiz.Web.Shared // Add using for the new component
@inject IQuestionService QuestionService
@inject ITeamService TeamService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IGameHistoryService GameHistoryService
@inject IGameStateService GameState
@inject ILogger<Game> Logger // Added Logger injection
@implements IDisposable

<MudContainer>
    @if (game == null)
    {
        <MudText>No active game found. Please <MudLink Href="/">start a new game</MudLink>.</MudText>
    }
    else if (game.IsGameOver)
    {
        <div class="game-container">
            <MudText Typo="Typo.h3" Align="Align.Center" Class="mb-4">Game Results ðŸŽ‰</MudText>
            
            @foreach (var question in game.Questions)
            {
                <MudPaper Class="pa-4 mb-4">
                    <MudText Typo="Typo.h5" Class="mb-3">@question.Question</MudText>
                    
                    <MudPaper Class="game-card matched"> @* Using consolidated class *@
                        <MudText Typo="Typo.subtitle1"><strong>@game.KingPlayer!.Name's Answer:</strong></MudText>
                        <MudText>@question.KingPlayerAnswer</MudText>
                    </MudPaper>
                    
                    <MudText Typo="Typo.h6" Class="mb-2">Player Guesses:</MudText>
                    @foreach (var answer in question.PlayerAnswers)
                    {
                        var matched = question.HasPlayerMatched(answer.Key);
                        <MudPaper Class="@(matched ? "game-card matched" : "game-card unmatched")"> @* Using consolidated classes *@
                            <MudText Typo="Typo.subtitle1">
                                <strong>@answer.Key:</strong> 
                                @answer.Value
                                @if (matched)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success" />
                                }
                            </MudText>
                        </MudPaper>
                    }
                </MudPaper>
            }
            
            <div class="d-flex justify-center mt-4">
                <MudButton Color="Color.Primary" 
                          Variant="Variant.Filled" 
                          OnClick="@(() => NavigationManager.NavigateTo("/"))" 
                          Class="mt-3">
                    Start New Game
                </MudButton>
            </div>
        </div>
    }
    else
    {
        <ScoreboardDisplay GameInstance="@game" /> @* Show score at the top *@
        <div class="game-container" style="position: relative;">
            <div class="@GetDifficultyBadgeClass()">
                @game.Difficulty.ToString()
            </div>
            
            <MudText Typo="Typo.h3" Align="Align.Center" Class="mb-4">Round @(game.CurrentRound + 1) ðŸŽ¯</MudText>
            
            <div class="progress-container">
                <MudText Typo="Typo.caption" Class="mb-1">Round progress: @(game.CurrentRound + 1)/@(game.MaxRounds)</MudText>
                <MudProgressLinear Value="@((game.CurrentRound + 1) * 100 / game.MaxRounds)" 
                                  Color="@GetProgressColor()" 
                                  Class="rounded-lg" 
                                  Striped="true" />
            </div>
            
            <div class="game-card question"> @* Using consolidated class *@
                <MudText Typo="Typo.h5" Align="Align.Center" Class="mb-4">@currentQuestion</MudText>
            </div>

            @* Use the new GameTimer component *@
            <GameTimer TotalSeconds="@(kingPlayerAnswered ? PlayerAnswerTime : KingAnswerTime)"
                       OnTimerElapsed="@HandleTimerElapsedAsync" />

            @if (!kingPlayerAnswered)
            {
                <div class="game-card answer"> @* Using consolidated class *@
                    <MudText Typo="Typo.h6" Class="mb-4">@game.KingPlayer!.Name's turn to answer ðŸ‘‘</MudText>
                    <MudTextField @bind-Value="@kingAnswer" 
                                Label="Your Answer" 
                                Required="true"
                                Variant="Variant.Outlined"
                                Class="mb-4" />
                    <MudButton Color="Color.Primary" 
                              Variant="Variant.Filled" 
                              OnClick="@SubmitKingAnswer" 
                              Class="mt-3"
                              StartIcon="@Icons.Material.Filled.Send">
                        Submit Answer
                    </MudButton>
                </div>
            }
            else
            {
                var nextPlayer = GetNextPlayerToAnswer();
                if (nextPlayer != null)
                {
                    <div class="game-card answer"> @* Using consolidated class *@
                        <MudText Typo="Typo.h6" Class="mb-4">@nextPlayer.Name's turn to guess what @game.KingPlayer!.Name answered ðŸ¤”</MudText>
                        <MudTextField @bind-Value="@currentPlayerAnswer" 
                                    Label="Your Guess" 
                                    Required="true"
                                    Variant="Variant.Outlined"
                                    Class="mb-4" />
                        <MudButton Color="Color.Secondary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@(() => SubmitPlayerGuess(nextPlayer.Name))" 
                                  Class="mt-3"
                                  StartIcon="@Icons.Material.Filled.Send">
                            Submit Guess
                        </MudButton>
                    </div>
                }
                else
                {
                    <div class="game-card answer"> @* Using consolidated class *@
                        <MudText Align="Align.Center">All players have answered. Moving to next round... ðŸŽ‰</MudText>
                    </div>
                }
            }

            @* ScoreboardDisplay is now at the top *@
        </div>
    }
</MudContainer>

@code {
    private PoCoupleQuiz.Core.Models.Game? game;
    private string currentQuestion = "";
    private string kingAnswer = "";
    private string currentPlayerAnswer = "";
    private bool kingPlayerAnswered;
    private DateTime _roundStartTime;
    private Question? _currentQuestion;
    private List<double> _responseTimes = new();
    private Dictionary<QuestionCategory, int> _categoryStats = new();
    private List<string> _matchedAnswers = new();
    private HashSet<string> _usedQuestions = new HashSet<string>(); // Track used questions
    
    // Timer properties - Moved to GameTimer component
    // private Timer? _timer;
    // private int RemainingSeconds { get; set; }
    // private bool IsTimerActive => RemainingSeconds > 0;
    private const int KingAnswerTime = 45;  // King has more time to provide their answer
    private int PlayerAnswerTime => game?.Difficulty switch
    {
        DifficultyLevel.Easy => 40,
        DifficultyLevel.Medium => 30,
        DifficultyLevel.Hard => 20,
        _ => 30
    };

    // Reference to the GameTimer component
    private GameTimer? GameTimerComponent;

    protected override async Task OnInitializedAsync()
    {
        game = GameState.CurrentGame;
        if (game == null)
        {
            Logger.LogWarning("Game state is null on initialization. Navigating to home.");
            NavigationManager.NavigateTo("/");
            return;
        }

        // Initialize game state
        game.Questions ??= new List<GameQuestion>();
        game.CurrentRound = Math.Min(game.CurrentRound, game.MaxRounds - 1);
        game.CurrentRound = Math.Max(0, game.CurrentRound);

        Logger.LogInformation("Game component initialized. CurrentRound: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);

        // Timer initialization moved to GameTimer component
        // _timer = new Timer(1000);
        // _timer.Elapsed += TimerTick;

        await StartNewRound();
    }
    
    // Timer methods moved to GameTimer component
    // private void StartTimer(int seconds) { ... }
    // private void StopTimer() { ... }
    // private void TimerTick(object? sender, ElapsedEventArgs e) { ... }
    
    // --- Timer Timeout Handlers ---
    
    private async Task HandleTimerElapsedAsync()
    {
        if (game == null)
        {
            Logger.LogWarning("HandleTimerElapsedAsync called with null game.");
            return;
        }

        Logger.LogInformation("Timer elapsed. King answered: {KingAnswered}", kingPlayerAnswered);

        if (!kingPlayerAnswered)
        {
            await HandleKingTimeoutAsync();
        }
        else
        {
            await HandlePlayerTimeoutAsync();
        }
        StateHasChanged(); // Ensure UI updates after handling timeout
    }

    private async Task HandleKingTimeoutAsync()
    {
        if (game == null)
        {
            Logger.LogWarning("HandleKingTimeoutAsync called with null game.");
            return;
        }

        Logger.LogInformation("King timeout occurred for round {RoundIndex}. King answer: {KingAnswer}", game.CurrentRound, kingAnswer);

        // Force submit king's answer if they have entered anything
        if (!string.IsNullOrWhiteSpace(kingAnswer))
        {
            Logger.LogInformation("Submitting partial king answer due to timeout.");
            await SubmitKingAnswer(); // Submit whatever was typed
        }
        else
        {
            // Skip this round entirely if king hasn't answered anything
            Snackbar.Add("King ran out of time! Skipping round...", Severity.Warning);
            Logger.LogInformation("King did not answer. Skipping round {RoundIndex}.", game.CurrentRound);
            await SafeIncrementRound(); // Advance round state
            
            if (game.IsGameOver)
            {
                Logger.LogInformation("Game over after king timeout.");
                await EndGame(); // Navigate to game over
            }
            else
            {
                Logger.LogInformation("Starting new round after king timeout.");
                await StartNewRound(); // Start the next round
            }
        }
    }

    private async Task HandlePlayerTimeoutAsync()
    {
        if (game == null)
        {
            Logger.LogWarning("HandlePlayerTimeoutAsync called with null game.");
            return;
        }

        Logger.LogInformation("Player timeout occurred for round {RoundIndex}.", game.CurrentRound);

        var nextPlayer = GetNextPlayerToAnswer();
        // TODO: Implement player timeout logic - currently just finds the next player

        // For now, just move to the next player or end the round if all have answered
        if (nextPlayer != null)
        {
            Logger.LogInformation("Moving to next player after timeout: {NextPlayerName}", nextPlayer.Name);
            // Start timer for the next player
            // StartTimer(PlayerAnswerTime); // Moved to GameTimer component
            // The GameTimer component will restart automatically when TotalSeconds parameter changes
        }
        else
        {
            Logger.LogInformation("All players answered or timed out. Processing end of round {RoundIndex}.", game.CurrentRound);
            await ProcessEndOfRound();
        }
    }

    public async Task SubmitKingAnswer()
    {
        if (game == null)
        {
            Logger.LogWarning("SubmitKingAnswer called with null game.");
            Snackbar.Add("Game not active.", Severity.Warning);
            return;
        }
        if (string.IsNullOrWhiteSpace(kingAnswer))
        {
            Snackbar.Add("Please enter an answer.", Severity.Warning);
            return;
        }

        try
        {
            EnsureCurrentQuestionExists();
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                var currentGameQuestion = game.Questions[currentRoundIndex];
                currentGameQuestion.KingPlayerAnswer = kingAnswer.Trim();
                kingPlayerAnswered = true;
                kingAnswer = ""; // Clear the input field
                // StopTimer(); // Moved to GameTimer component - will stop when TotalSeconds changes to 0 or next player time

                // Start timer for the first player to guess
                // StartTimer(PlayerAnswerTime); // Moved to GameTimer component - will start when TotalSeconds changes

                Logger.LogInformation("King answer submitted for round {RoundIndex}.", game.CurrentRound);
                StateHasChanged();
            }
            else
            {
                 Logger.LogError("SubmitKingAnswer: Invalid CurrentRound index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
                 Snackbar.Add("Error submitting answer. Invalid game state.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error submitting king answer for round {RoundIndex}.", game.CurrentRound);
            Snackbar.Add("Error submitting answer. Please try again.", Severity.Error);
        }
    }

    public async Task SubmitPlayerGuess(string playerName)
    {
        if (game == null)
        {
            Logger.LogWarning("SubmitPlayerGuess called with null game.");
            Snackbar.Add("Game not active.", Severity.Warning);
            return;
        }
         if (string.IsNullOrWhiteSpace(currentPlayerAnswer))
        {
            Snackbar.Add("Please enter a guess.", Severity.Warning);
            return;
        }

        try
        {
            EnsureCurrentQuestionExists();
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                var currentGameQuestion = game.Questions[currentRoundIndex];
                currentGameQuestion.RecordPlayerAnswer(playerName, currentPlayerAnswer);
                currentPlayerAnswer = ""; // Clear the input field
                GameTimerComponent?.StopTimer(); // Stop the timer after a player submits

                Logger.LogInformation("Player guess submitted for round {RoundIndex} by {PlayerName}.", game.CurrentRound, playerName);

                if (game.AllPlayersAnswered(currentRoundIndex))
                {
                    Logger.LogInformation("All players have answered for round {RoundIndex}. Processing end of round.", game.CurrentRound);
                    await ProcessEndOfRound();
                }
                else
                {
                    var nextPlayer = GetNextPlayerToAnswer();
                    if (nextPlayer != null)
                    {
                        Logger.LogInformation("Moving to next player to guess: {NextPlayerName}", nextPlayer.Name);
                        // Start timer for the next player
                        // StartTimer(PlayerAnswerTime); // Moved to GameTimer component
                        // The GameTimer component will restart automatically when TotalSeconds parameter changes
                    }
                    else
                    {
                         Logger.LogWarning("SubmitPlayerGuess: Expected next player but none found after submission.");
                    }
                }
                StateHasChanged();
            }
             else
            {
                 Logger.LogError("SubmitPlayerGuess: Invalid CurrentRound index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
                 Snackbar.Add("Error submitting guess. Invalid game state.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error submitting player guess for round {RoundIndex} by {PlayerName}.", game.CurrentRound, playerName);
            Snackbar.Add("Error submitting guess. Please try again.", Severity.Error);
        }
    }

    public async Task StartNewRound()
    {
        if (game == null)
        {
            Logger.LogWarning("StartNewRound called with null game.");
            return;
        }

        Logger.LogInformation("Starting new round {CurrentRoundPlusOne}.", game.CurrentRound + 1);

        kingPlayerAnswered = false;
        kingAnswer = "";
        currentPlayerAnswer = "";
        _roundStartTime = DateTime.UtcNow;

        try
        {
            // Track used questions to prevent duplicates
            int attempts = 0;
            const int maxAttempts = 10; // Limit attempts to avoid infinite loops
            do
            {
                _currentQuestion = await QuestionService.GenerateQuestionAsync(game.Difficulty.ToString());
                currentQuestion = _currentQuestion.Text;
                attempts++;
            } while (_usedQuestions.Contains(currentQuestion) && attempts < maxAttempts);

            if (_usedQuestions.Contains(currentQuestion))
            {
                 Logger.LogWarning("Could not find a unique question after {Attempts} attempts.", attempts);
                 // Handle case where unique question cannot be found (e.g., all questions used)
                 // For now, just use the last generated question even if duplicate
            }
            
            _usedQuestions.Add(currentQuestion); // Add the question to the used set
            Logger.LogInformation("Generated new question for round {RoundIndex}: {QuestionText}", game.CurrentRound, currentQuestion);

            EnsureCurrentQuestionExists();
            // Start timer for the king's answer
            // StartTimer(KingAnswerTime); // Moved to GameTimer component
            // The GameTimer component will start automatically when TotalSeconds parameter changes

            StateHasChanged(); // Ensure UI updates after starting new round
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting new round {RoundIndex}.", game.CurrentRound);
            Snackbar.Add("Error starting new round. Please try again.", Severity.Error);
        }
    }

    public async Task EndGame()
    {
        if (game == null)
        {
            Logger.LogWarning("EndGame called with null game.");
            return;
        }

        Logger.LogInformation("Ending game. Final round: {CurrentRound}.", game.CurrentRound);

        GameTimerComponent?.StopTimer(); // Stop the timer when the game ends
        game.CurrentRound = game.MaxRounds;
        
        try
        {
            // Create a GameHistory object with the proper properties
            var gameHistory = new GameHistory
            {
                PartitionKey = "Games",
                RowKey = GameHistory.GenerateRowKey(),
                Date = DateTime.UtcNow,
                GameMode = GameMode.KingPlayer, // Using the correct enum value that exists
                Team1Name = game.KingPlayer?.Name ?? "Player 1",
                Team2Name = game.Players.FirstOrDefault(p => !p.IsKingPlayer)?.Name ?? "Player 2",
                Team1Score = game.KingPlayer?.Score ?? 0,
                Team2Score = game.Players.Where(p => !p.IsKingPlayer).Sum(p => p.Score),
                TotalQuestions = game.Questions.Count,
                AverageResponseTime = _responseTimes.Count > 0 ? _responseTimes.Average() : 0,
                CategoryStats = string.Empty, // Can be JSON serialized from _categoryStats if needed
                MatchedAnswers = string.Empty // Can be JSON serialized from _matchedAnswers if needed
            };
            
            await GameHistoryService.SaveGameHistoryAsync(gameHistory);
            Logger.LogInformation("Game history saved.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving game history.");
            Snackbar.Add("Error saving game history.", Severity.Error);
        }

        StateHasChanged();
    }

    public GameQuestion GetCurrentQuestion()
    {
        if (game == null)
        {
            Logger.LogWarning("GetCurrentQuestion called with null game.");
            return new GameQuestion();
        }
        EnsureCurrentQuestionExists();
        var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
         if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
        {
            return game.Questions[currentRoundIndex];
        }
        else
        {
            Logger.LogError("GetCurrentQuestion: Invalid CurrentRound index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
            return new GameQuestion(); // Return empty question to avoid null reference
        }
    }

    private Player? GetNextPlayerToAnswer()
    {
        if (game == null)
        {
            Logger.LogWarning("GetNextPlayerToAnswer called with null game.");
            return null;
        }
        // Use the method directly from the ScoreboardDisplay component instance if needed elsewhere,
        // or pass the necessary state down. For now, GetNextPlayerToAnswer needs this logic.
        // Let's replicate the check here temporarily until further refactoring.
        var nextPlayer = game.Players.FirstOrDefault(p => !p.IsKingPlayer && !InternalSafeHasPlayerAnswered(p.Name));
        if (nextPlayer == null)
        {
             Logger.LogInformation("No next player found to answer.");
        }
        return nextPlayer;
    }

    // Removed HasPlayerAnswered as it was just a wrapper for the removed SafeHasPlayerAnswered
    
    // Replicate the check needed by GetNextPlayerToAnswer locally
    private bool InternalSafeHasPlayerAnswered(string playerName)
    {
        if (game == null)
        {
            Logger.LogWarning("InternalSafeHasPlayerAnswered called with null game.");
            return false;
        }
        game.Questions ??= new List<GameQuestion>();
        if (game.CurrentRound < 0 || game.CurrentRound >= game.Questions.Count)
        {
             Logger.LogWarning("InternalSafeHasPlayerAnswered: Invalid CurrentRound index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
             return false;
        }
        var currentGameQuestion = game.Questions[game.CurrentRound];
        if (game.KingPlayer?.Name == playerName) return !string.IsNullOrEmpty(currentGameQuestion.KingPlayerAnswer);
        return currentGameQuestion.HasPlayerAnswered(playerName);
    }
    
    // Removed SafeHasPlayerAnswered as it's now in ScoreboardDisplay.razor
    // private bool SafeHasPlayerAnswered(string playerName) { ... }

    private void EnsureCurrentQuestionExists()
    {
        if (game == null)
        {
            Logger.LogWarning("EnsureCurrentQuestionExists called with null game.");
            return;
        }
        
        // Ensure Questions list is initialized
        game.Questions ??= new List<GameQuestion>();
        
        // Make sure current round is in bounds
        game.CurrentRound = Math.Max(0, Math.Min(game.CurrentRound, game.MaxRounds - 1));
        
        // Add questions if needed to match the current round
        while (game.CurrentRound >= game.Questions.Count)
        {
            game.Questions.Add(new GameQuestion { Question = currentQuestion });
            Logger.LogWarning("Added missing question for round {RoundIndex}. Questions count now: {QuestionsCount}", game.Questions.Count - 1, game.Questions.Count);
        }
         Logger.LogDebug("Ensured current question exists for round {RoundIndex}. Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
    }

    private async Task ProcessEndOfRound()
    {
        if (game == null)
        {
            Logger.LogWarning("ProcessEndOfRound called with null game.");
            return;
        }

        Logger.LogInformation("Processing end of round {CurrentRound}.", game.CurrentRound);
        
        try
        {
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                game.UpdateScores(currentRoundIndex);
                Logger.LogInformation("Scores updated for round {RoundIndex}.", game.CurrentRound);
                
                // Capture matched answers for statistics
                var currentGameQuestion = game.Questions[currentRoundIndex];
                foreach (var player in currentGameQuestion.PlayersMatched)
                {
                    _matchedAnswers.Add($"{player}:{currentGameQuestion.Question}");
                    Logger.LogDebug("Matched answer recorded: {Player}:{Question}", player, currentGameQuestion.Question);
                }
                
                // Increment round and start next round or end game
                await SafeIncrementRound();
                if (game.IsGameOver)
                {
                    Logger.LogInformation("Game is over after processing round {RoundIndex}.", game.CurrentRound);
                    await EndGame();
                }
                else
                {
                    Logger.LogInformation("Starting new round after processing round {RoundIndex}.", game.CurrentRound);
                    await StartNewRound();
                }
            }
            else
            {
                Logger.LogError("Error in ProcessEndOfRound: Invalid round index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
                Snackbar.Add("Error processing round. Invalid game state.", Severity.Error);
                await SafeIncrementRound(); // Attempt to move to next round despite error
                if (game.IsGameOver)
                {
                    await EndGame();
                }
                else
                {
                    await StartNewRound();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing end of round {RoundIndex}: {ErrorMessage}", game.CurrentRound, ex.Message);
            Snackbar.Add("Error processing round. Please try again.", Severity.Error);
            await SafeIncrementRound(); // Attempt to move to next round despite error
            if (game.IsGameOver)
            {
                await EndGame();
            }
            else
            {
                await StartNewRound();
            }
        }
        
        StateHasChanged();
    }
    
    private async Task SafeIncrementRound()
    {
        if (game == null)
        {
            Logger.LogWarning("SafeIncrementRound called with null game.");
            return;
        }
        
        // Increment round with bounds checking
        game.CurrentRound++;
        
        // Ensure within max bounds
        if (game.CurrentRound >= game.MaxRounds)
        {
            game.CurrentRound = game.MaxRounds;
        }
        
        // Log the round transition for debugging
        Logger.LogInformation("Moving to round {CurrentRoundPlusOne}. Total questions: {QuestionsCount}, Max rounds: {MaxRounds}", game.CurrentRound + 1, game.Questions.Count, game.MaxRounds);
    }

    private string GetDifficultyBadgeClass() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => "difficulty-badge easy-badge",
        DifficultyLevel.Medium => "difficulty-badge medium-badge",
        DifficultyLevel.Hard => "difficulty-badge hard-badge",
        _ => "difficulty-badge medium-badge"
    };
    
    private Color GetProgressColor() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => Color.Success,
        DifficultyLevel.Medium => Color.Warning,
        DifficultyLevel.Hard => Color.Error,
        _ => Color.Warning
    };
    
    // --- Timer UI Helper Methods ---
    
    // Moved to GameTimer component
    // private double GetTimerProgress() { ... }
    // private Color GetTimerColor() { ... }

    // --- End Timer UI Helper Methods ---

    public void Dispose()
    {
        // Dispose of the timer in the GameTimer component
        GameTimerComponent?.Dispose();
        Logger.LogInformation("Game component disposed.");
    }
}

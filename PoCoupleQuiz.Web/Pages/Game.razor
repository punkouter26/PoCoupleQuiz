@page "/game/king"
@using PoCoupleQuiz.Core.Models
@using PoCoupleQuiz.Core.Services
@using Microsoft.AspNetCore.Components
@using MudBlazor
@using System.Text.Json
@using System.Timers
@inject IQuestionService QuestionService
@inject ITeamService TeamService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IGameHistoryService GameHistoryService
@inject IGameStateService GameState
@implements IDisposable

<style>
    .game-container {
        background: linear-gradient(135deg, #FFF8E1, #FFE0B2);
        padding: 2rem;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .question-container {
        background-color: #F8BBD0;
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .answer-container {
        background-color: white;
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .scoreboard {
        background-color: #E1BEE7;
        padding: 1.5rem;
        border-radius: 15px;
        margin-top: 1.5rem;
    }

    .player-chip {
        margin: 0.5rem;
        transition: transform 0.2s;
    }

    .player-chip:hover {
        transform: scale(1.1);
    }

    .difficulty-badge {
        position: absolute;
        top: 1rem;
        right: 1rem;
        padding: 0.4rem 0.8rem;
        border-radius: 12px;
        font-weight: bold;
    }
    
    .easy-badge {
        background-color: #A5D6A7;
        color: #1B5E20;
    }
    
    .medium-badge {
        background-color: #FFE082;
        color: #FF6F00;
    }
    
    .hard-badge {
        background-color: #EF9A9A;
        color: #B71C1C;
    }
    
    .progress-container {
        margin: 1rem 0;
    }
    
    .timer-container {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 1rem;
    }
    
    .timer {
        font-size: 1.5rem;
        font-weight: bold;
        text-align: center;
        margin: 0 1rem;
        min-width: 60px;
    }
    
    .timer-critical {
        color: #B71C1C;
    }
    
    .matched-answer {
        background-color: #DCEDC8;
        border-left: 4px solid #8BC34A;
    }
    
    .unmatched-answer {
        background-color: #FFECB3;
        border-left: 4px solid #FFC107;
    }
</style>

<MudContainer>
    @if (game == null)
    {
        <MudText>No active game found. Please <MudLink Href="/">start a new game</MudLink>.</MudText>
    }
    else
    {
        <div class="game-container" style="position: relative;">
            <div class="@GetDifficultyBadgeClass()">
                @game.Difficulty.ToString()
            </div>
            
            <MudText Typo="Typo.h3" Align="Align.Center" Class="mb-4">Round @(game.CurrentRound + 1) üéØ</MudText>
            
            <div class="progress-container">
                <MudText Typo="Typo.caption" Class="mb-1">Round progress: @(game.CurrentRound + 1)/@(game.MaxRounds)</MudText>
                <MudProgressLinear Value="@((game.CurrentRound + 1) * 100 / game.MaxRounds)" 
                                  Color="@GetProgressColor()" 
                                  Class="rounded-lg" 
                                  Striped="true" />
            </div>
            
            <div class="question-container">
                <MudText Typo="Typo.h5" Align="Align.Center" Class="mb-4">@currentQuestion</MudText>
            </div>

            @if (IsTimerActive)
            {
                <div class="timer-container">
                    <MudIcon Icon="@Icons.Material.Filled.Timer" Color="@(RemainingSeconds <= 5 ? Color.Error : Color.Default)" />
                    <div class="timer @(RemainingSeconds <= 5 ? "timer-critical" : "")">@RemainingSeconds</div>
                    <MudText>seconds remaining</MudText>
                </div>
            }

            @if (!kingPlayerAnswered)
            {
                <div class="answer-container">
                    <MudText Typo="Typo.h6" Class="mb-4">@game.KingPlayer!.Name's turn to answer üëë</MudText>
                    <MudTextField @bind-Value="@kingAnswer" 
                                Label="Your Answer" 
                                Required="true"
                                Variant="Variant.Outlined"
                                Class="mb-4" />
                    <MudButton Color="Color.Primary" 
                              Variant="Variant.Filled" 
                              OnClick="@SubmitKingAnswer" 
                              Class="mt-3"
                              StartIcon="@Icons.Material.Filled.Send">
                        Submit Answer
                    </MudButton>
                </div>
            }
            else if (showingRoundSummary && game.Questions.Count > 0)
            {
                // Use safe index calculation with bounds checking
                var prevRoundIndex = Math.Max(0, Math.Min(game.CurrentRound - 1, game.Questions.Count - 1));
                var hasPreviousRound = prevRoundIndex >= 0 && prevRoundIndex < game.Questions.Count;
                
                <div class="answer-container">
                    <MudText Typo="Typo.h5" Align="Align.Center" Class="mb-4">Round @(prevRoundIndex + 1) Summary</MudText>
                    
                    @if (hasPreviousRound)
                    {
                        <MudPaper Class="pa-3 mb-4 matched-answer">
                            <MudText Typo="Typo.subtitle1"><strong>@game.KingPlayer!.Name's Answer:</strong></MudText>
                            <MudText>@game.Questions[prevRoundIndex].KingPlayerAnswer</MudText>
                        </MudPaper>
                        
                        <MudText Typo="Typo.h6" Class="mb-2">Player Guesses:</MudText>
                        @foreach (var answer in game.Questions[prevRoundIndex].PlayerAnswers)
                        {
                            var matched = game.Questions[prevRoundIndex].HasPlayerMatched(answer.Key);
                            <MudPaper Class="@(matched ? "pa-3 mb-2 matched-answer" : "pa-3 mb-2 unmatched-answer")">
                                <MudText Typo="Typo.subtitle1">
                                    <strong>@answer.Key:</strong> 
                                    @answer.Value
                                    @if (matched)
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success" />
                                    }
                                </MudText>
                            </MudPaper>
                        }
                    }
                    else
                    {
                        <MudText Color="Color.Error">Error: Unable to display round summary. Previous round data not found.</MudText>
                    }
                    
                    <div class="d-flex justify-center mt-4">
                        <MudButton Color="Color.Primary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@ContinueToNextRound" 
                                  Class="mt-3">
                            @(game.IsGameOver ? "See Final Results" : "Continue to Next Round")
                        </MudButton>
                    </div>
                </div>
            }
            else if (showingRoundSummary)
            {
                <div class="answer-container">
                    <MudText Typo="Typo.h5" Color="Color.Error">An error occurred displaying the round summary. Starting next round...</MudText>
                    <div class="d-flex justify-center mt-4">
                        <MudButton Color="Color.Primary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@ContinueToNextRound" 
                                  Class="mt-3">
                            Continue
                        </MudButton>
                    </div>
                </div>
            }
            else
            {
                var nextPlayer = GetNextPlayerToAnswer();
                if (nextPlayer != null)
                {
                    <div class="answer-container">
                        <MudText Typo="Typo.h6" Class="mb-4">@nextPlayer.Name's turn to guess what @game.KingPlayer!.Name answered ü§î</MudText>
                        <MudTextField @bind-Value="@currentPlayerAnswer" 
                                    Label="Your Guess" 
                                    Required="true"
                                    Variant="Variant.Outlined"
                                    Class="mb-4" />
                        <MudButton Color="Color.Secondary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@(() => SubmitPlayerGuess(nextPlayer.Name))" 
                                  Class="mt-3"
                                  StartIcon="@Icons.Material.Filled.Send">
                            Submit Guess
                        </MudButton>
                    </div>
                }
                else
                {
                    <div class="answer-container">
                        <MudText Align="Align.Center">All players have answered. Moving to round summary... üéâ</MudText>
                    </div>
                }
            }

            <div class="scoreboard">
                <MudText Typo="Typo.h5" Class="mb-4">Scoreboard üèÜ</MudText>
                @foreach (var score in game.GetScoreboard())
                {
                    <MudText>@score.Key: @score.Value points ‚≠ê</MudText>
                }

                <MudDivider Class="my-4" />

                <MudText Typo="Typo.h6" Class="mb-2">Players who have answered:</MudText>
                <div style="display: flex; flex-wrap: wrap;">
                    @foreach (var player in game.Players)
                    {
                        <MudChip T="string" 
                                Color="@(SafeHasPlayerAnswered(player.Name) ? Color.Success : Color.Default)"
                                Class="player-chip"
                                Icon="@(player.IsKingPlayer ? Icons.Material.Filled.Stars : Icons.Material.Filled.Person)">
                            @(player.Name + (player.IsKingPlayer ? " (King)" : ""))
                        </MudChip>
                    }
                </div>
            </div>
        </div>
    }
</MudContainer>

@code {
    private PoCoupleQuiz.Core.Models.Game? game;
    private string currentQuestion = "";
    private string kingAnswer = "";
    private string currentPlayerAnswer = "";
    private bool kingPlayerAnswered;
    private DateTime _roundStartTime;
    private Question? _currentQuestion;
    private List<double> _responseTimes = new();
    private Dictionary<QuestionCategory, int> _categoryStats = new();
    private List<string> _matchedAnswers = new();
    private bool showingRoundSummary = false;
    
    // Timer properties
    private Timer? _timer;
    private int RemainingSeconds { get; set; }
    private bool IsTimerActive => RemainingSeconds > 0;
    private const int KingAnswerTime = 45;  // King has more time to provide their answer
    private int PlayerAnswerTime => game?.Difficulty switch
    {
        DifficultyLevel.Easy => 40,
        DifficultyLevel.Medium => 30,
        DifficultyLevel.Hard => 20,
        _ => 30
    };

    protected override async Task OnInitializedAsync()
    {
        game = GameState.CurrentGame;
        if (game == null)
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        // Initialize game state
        game.Questions ??= new List<GameQuestion>();
        game.CurrentRound = Math.Min(game.CurrentRound, game.MaxRounds - 1);
        game.CurrentRound = Math.Max(0, game.CurrentRound);

        Console.WriteLine($"Game initialized. CurrentRound: {game.CurrentRound}, Questions count: {game.Questions.Count}");

        _timer = new Timer(1000);
        _timer.Elapsed += TimerTick;

        await StartNewRound();
    }
    
    private void StartTimer(int seconds)
    {
        RemainingSeconds = seconds;
        _timer?.Start();
    }
    
    private void StopTimer()
    {
        _timer?.Stop();
        RemainingSeconds = 0;
    }
    
    private void TimerTick(object? sender, ElapsedEventArgs e)
    {
        if (RemainingSeconds <= 0)
        {
            _timer?.Stop();
            
            // Time's up!
            InvokeAsync(async () =>
            {
                if (!kingPlayerAnswered)
                {
                    // Force submit king's answer if they have entered anything
                    if (!string.IsNullOrWhiteSpace(kingAnswer))
                    {
                        await SubmitKingAnswer();
                    }
                    else
                    {
                        // Skip this round if king hasn't answered
                        Snackbar.Add("Time's up! Moving to next round...", Severity.Warning);
                        await SafeIncrementRound();
                        
                        if (game!.IsGameOver)
                        {
                            await EndGame();
                        }
                        else
                        {
                            await StartNewRound();
                        }
                    }
                }
                else
                {
                    var nextPlayer = GetNextPlayerToAnswer();
                    if (nextPlayer != null)
                    {
                        // Force submit player's guess if they have entered anything
                        if (!string.IsNullOrWhiteSpace(currentPlayerAnswer))
                        {
                            await SubmitPlayerGuess(nextPlayer.Name);
                        }
                        else
                        {
                            // Skip this player's turn and move to next player
                            Snackbar.Add($"{nextPlayer.Name} ran out of time!", Severity.Warning);
                            
                            // Safely record an empty answer for this player
                            EnsureCurrentQuestionExists();
                            
                            var currentRoundIndex = Math.Min(game!.CurrentRound, game.Questions.Count - 1);
                            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
                            {
                                var currentGameQuestion = game.Questions[currentRoundIndex];
                                currentGameQuestion.RecordPlayerAnswer(nextPlayer.Name, "");
                                
                                if (game.AllPlayersAnswered(currentRoundIndex))
                                {
                                    // All players have answered, move to next round
                                    await ProcessEndOfRound();
                                }
                                else
                                {
                                    nextPlayer = GetNextPlayerToAnswer();
                                    if (nextPlayer != null)
                                    {
                                        StartTimer(PlayerAnswerTime);
                                    }
                                }
                            }
                            else
                            {
                                // Handle invalid round index
                                Console.WriteLine($"Warning: Invalid round index in TimerTick. CurrentRound: {game.CurrentRound}, Questions count: {game.Questions.Count}");
                                // Recover by creating a new question
                                await StartNewRound();
                            }
                        }
                    }
                }
                StateHasChanged();
            });
        }
        else
        {
            RemainingSeconds--;
            InvokeAsync(StateHasChanged);
        }
    }

    private Player? GetNextPlayerToAnswer()
    {
        if (game == null) return null;
        return game.Players.FirstOrDefault(p => !p.IsKingPlayer && !SafeHasPlayerAnswered(p.Name));
    }

    private bool HasPlayerAnswered(string playerName)
    {
        return SafeHasPlayerAnswered(playerName);
    }
    
    private bool SafeHasPlayerAnswered(string playerName)
    {
        if (game == null) return false;
        
        // Ensure Questions list is initialized
        game.Questions ??= new List<GameQuestion>();
        
        // Check if CurrentRound is valid
        if (game.CurrentRound < 0 || game.CurrentRound >= game.Questions.Count)
        {
            // Log the issue but don't crash
            Console.WriteLine($"Warning in SafeHasPlayerAnswered: Invalid CurrentRound index: {game.CurrentRound}, Questions count: {game.Questions.Count}");
            return false;
        }
        
        var currentGameQuestion = game.Questions[game.CurrentRound];
        if (game.KingPlayer?.Name == playerName)
            return !string.IsNullOrEmpty(currentGameQuestion.KingPlayerAnswer);
            
        return currentGameQuestion.HasPlayerAnswered(playerName);
    }

    private void EnsureCurrentQuestionExists()
    {
        if (game == null) return;
        
        // Ensure Questions list is initialized
        game.Questions ??= new List<GameQuestion>();
        
        // Make sure current round is in bounds
        game.CurrentRound = Math.Max(0, Math.Min(game.CurrentRound, game.MaxRounds - 1));
        
        // Add questions if needed to match the current round
        while (game.CurrentRound >= game.Questions.Count)
        {
            game.Questions.Add(new GameQuestion { Question = currentQuestion });
            Console.WriteLine($"Added missing question for round {game.Questions.Count-1}. Questions count now: {game.Questions.Count}");
        }
    }

    private async Task StartNewRound()
    {
        if (game == null) return;

        // Reset round state
        showingRoundSummary = false;
        kingPlayerAnswered = false;
        kingAnswer = "";
        currentPlayerAnswer = "";
        _roundStartTime = DateTime.UtcNow;
        
        // Ensure current round is within valid bounds
        game.CurrentRound = Math.Max(0, Math.Min(game.CurrentRound, game.MaxRounds - 1));
        
        Console.WriteLine($"Starting round {game.CurrentRound + 1}/{game.MaxRounds}");
        
        // Ensure we have a GameQuestion object for the current round
        EnsureCurrentQuestionExists();
        
        // Generate question based on difficulty
        try 
        {
            currentQuestion = game.Difficulty switch
            {
                DifficultyLevel.Easy => await QuestionService.GenerateQuestionAsync("easy"),
                DifficultyLevel.Hard => await QuestionService.GenerateQuestionAsync("hard"),
                _ => await QuestionService.GenerateQuestionAsync()
            };
            
            Console.WriteLine($"Generated question for round {game.CurrentRound + 1}: {currentQuestion}");
            
            _currentQuestion = new Question { Text = currentQuestion };
            
            // Update the question for this round
            game.Questions[game.CurrentRound].Question = currentQuestion;
            
            // Start the timer for king's answer
            StartTimer(KingAnswerTime);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating question: {ex}");
            Snackbar.Add("Error generating question. Using a default question.", Severity.Warning);
            
            // Use a fallback question
            currentQuestion = "What is their favorite food?";
            _currentQuestion = new Question { Text = currentQuestion };
            game.Questions[game.CurrentRound].Question = currentQuestion;
            
            // Start the timer for king's answer
            StartTimer(KingAnswerTime);
        }

        StateHasChanged();
    }

    private async Task SubmitKingAnswer()
    {
        if (game == null || string.IsNullOrWhiteSpace(kingAnswer)) return;

        // Stop the timer
        StopTimer();

        // Ensure the current game question exists
        EnsureCurrentQuestionExists();
        
        var currentGameQuestion = game.Questions[game.CurrentRound];
        currentGameQuestion.KingPlayerAnswer = kingAnswer;
        kingPlayerAnswered = true;
        Snackbar.Add("Answer submitted!", Severity.Success);
        
        var nextPlayer = GetNextPlayerToAnswer();
        if (nextPlayer != null)
        {
            // Start timer for first player's guess
            StartTimer(PlayerAnswerTime);
        }
        
        StateHasChanged();
    }

    private async Task SubmitPlayerGuess(string playerName)
    {
        if (game == null || _currentQuestion == null) return;

        // Stop the timer
        StopTimer();

        var responseTime = (DateTime.UtcNow - _roundStartTime).TotalSeconds;
        _responseTimes.Add(responseTime);

        // Ensure the current game question exists
        EnsureCurrentQuestionExists();

        var currentGameQuestion = game.Questions[game.CurrentRound];
        
        // Record the player's answer
        currentGameQuestion.RecordPlayerAnswer(playerName, currentPlayerAnswer);
        
        // Check if the answer matches the king's answer
        // First do a simple case-insensitive check
        bool isMatch = string.Equals(currentPlayerAnswer, currentGameQuestion.KingPlayerAnswer, StringComparison.OrdinalIgnoreCase);
        
        // If not an exact match, try semantic similarity check with OpenAI
        if (!isMatch && !string.IsNullOrWhiteSpace(currentPlayerAnswer) && !string.IsNullOrWhiteSpace(currentGameQuestion.KingPlayerAnswer))
        {
            try
            {
                // Use AI to check for semantic similarity
                isMatch = await QuestionService.CheckAnswerSimilarityAsync(currentGameQuestion.KingPlayerAnswer, currentPlayerAnswer);
                Console.WriteLine($"Semantic similarity check for '{currentPlayerAnswer}' against '{currentGameQuestion.KingPlayerAnswer}': {isMatch}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error checking answer similarity: {ex.Message}. Falling back to simple comparison.");
                
                // Fallback to simple contains check if API fails
                isMatch = currentPlayerAnswer.ToLowerInvariant().Contains(currentGameQuestion.KingPlayerAnswer.ToLowerInvariant()) || 
                         currentGameQuestion.KingPlayerAnswer.ToLowerInvariant().Contains(currentPlayerAnswer.ToLowerInvariant());
            }
        }
        
        // If the answers match, mark the player as having a match
        if (isMatch)
        {
            currentGameQuestion.MarkPlayerAsMatched(playerName);
            Console.WriteLine($"Player {playerName}'s answer matches! Marked as matched.");
            Snackbar.Add("Good guess! That matches the king's answer!", Severity.Success);
        }
        else
        {
            Console.WriteLine($"Player {playerName}'s answer does not match.");
            Snackbar.Add("Submitted your guess!", Severity.Info);
        }
        
        currentPlayerAnswer = "";
        StateHasChanged();

        // Check if all players have answered
        var allPlayersAnswered = game.AllPlayersAnswered(game.CurrentRound);
        if (allPlayersAnswered)
        {
            await ProcessEndOfRound();
        }
        else
        {
            var nextPlayer = GetNextPlayerToAnswer();
            if (nextPlayer != null)
            {
                // Start timer for next player's guess
                StartTimer(PlayerAnswerTime);
            }
        }
    }
    
    private Task ProcessEndOfRound()
    {
        if (game == null) return Task.CompletedTask;
        
        try
        {
            // Ensure the current round is valid
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                game.UpdateScores(currentRoundIndex);
                
                // Show round summary instead of immediately proceeding
                showingRoundSummary = true;
                
                // Capture matched answers for statistics
                var currentGameQuestion = game.Questions[currentRoundIndex];
                foreach (var player in currentGameQuestion.PlayersMatched)
                {
                    _matchedAnswers.Add($"{player}:{currentGameQuestion.Question}");
                }
            }
            else
            {
                Console.WriteLine($"Error in ProcessEndOfRound: Invalid round index: {game.CurrentRound}, Questions count: {game.Questions.Count}");
                // Still proceed to show summary screen
                showingRoundSummary = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing end of round: {ex.Message}");
            // Still proceed to show summary screen
            showingRoundSummary = true;
        }
        
        StateHasChanged();
        return Task.CompletedTask;
    }
    
    private async Task SafeIncrementRound()
    {
        if (game == null) return;
        
        // Increment round with bounds checking
        game.CurrentRound++;
        
        // Ensure within max bounds
        if (game.CurrentRound >= game.MaxRounds)
        {
            game.CurrentRound = game.MaxRounds;
        }
        
        // Log the round transition for debugging
        Console.WriteLine($"Moving to round {game.CurrentRound + 1}. Total questions: {game.Questions.Count}, Max rounds: {game.MaxRounds}");
    }
    
    private Task ContinueToNextRound()
    {
        if (game == null) return Task.CompletedTask;
        
        // Increment round safely
        SafeIncrementRound();
        
        if (game.IsGameOver)
        {
            return EndGame();
        }
        else
        {
            return StartNewRound();
        }
    }
    
    private async Task EndGame()
    {
        if (game == null) return;
        
        // Save game history
        var history = new GameHistory
        {
            Team1Name = game.KingPlayer!.Name,
            Team2Name = "Multiple Players",
            GameMode = GameMode.KingPlayer,
            Team1Score = game.Players.Max(p => p.Score),
            TotalQuestions = Math.Min(game.CurrentRound, game.Questions.Count),
            AverageResponseTime = _responseTimes.Count > 0 ? _responseTimes.Average() : 0,
            CategoryStats = JsonSerializer.Serialize(_categoryStats),
            MatchedAnswers = JsonSerializer.Serialize(_matchedAnswers)
        };
        await GameHistoryService.SaveGameHistoryAsync(history);

        // Save player stats
        foreach (var player in game.Players)
        {
            await TeamService.SaveTeamAsync(new Team 
            { 
                Name = player.Name,
                MultiplayerWins = player.Score > 0 ? 1 : 0,
                TotalQuestionsAnswered = Math.Min(game.CurrentRound, game.Questions.Count),
                CorrectAnswers = player.TotalCorrectGuesses
            });
        }

        GameState.ClearGame();
        var winner = game.Players.OrderByDescending(p => p.Score).First();
        var scores = string.Join("|", game.GetScoreboard().Select(s => $"{s.Key}:{s.Value}"));
        NavigationManager.NavigateTo($"/game-over/king/{game.KingPlayer!.Name}/{winner.Name}/{winner.Score}/{Uri.EscapeDataString(scores)}");
        return;
    }

    private string GetDifficultyBadgeClass() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => "difficulty-badge easy-badge",
        DifficultyLevel.Medium => "difficulty-badge medium-badge",
        DifficultyLevel.Hard => "difficulty-badge hard-badge",
        _ => "difficulty-badge medium-badge"
    };
    
    private Color GetProgressColor() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => Color.Success,
        DifficultyLevel.Medium => Color.Warning,
        DifficultyLevel.Hard => Color.Error,
        _ => Color.Warning
    };

    public void Dispose()
    {
        if (_timer != null)
        {
            _timer.Elapsed -= TimerTick;
            _timer.Dispose();
        }
    }
}

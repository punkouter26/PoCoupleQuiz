@page "/game/king"
@using PoCoupleQuiz.Core.Models
@using PoCoupleQuiz.Core.Services
@using Microsoft.AspNetCore.Components
@using MudBlazor
@using System.Text.Json
@using System.Timers
@using Microsoft.Extensions.Logging // Added Logging
@inject IQuestionService QuestionService
@inject ITeamService TeamService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IGameHistoryService GameHistoryService
@inject IGameStateService GameState
@inject ILogger<Game> Logger // Added Logger injection
@implements IDisposable

<style>
    .game-container {
        background: linear-gradient(135deg, #FFF8E1, #FFE0B2);
        padding: 2rem;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .question-container {
        background-color: #F8BBD0;
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .answer-container {
        background-color: white;
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .scoreboard {
        background-color: #E1BEE7;
        padding: 1.5rem;
        border-radius: 15px;
        margin-top: 1.5rem;
    }

    .player-chip {
        margin: 0.5rem;
        transition: transform 0.2s;
    }

    .player-chip:hover {
        transform: scale(1.1);
    }

    .difficulty-badge {
        position: absolute;
        top: 1rem;
        right: 1rem;
        padding: 0.4rem 0.8rem;
        border-radius: 12px;
        font-weight: bold;
    }
    
    .easy-badge {
        background-color: #A5D6A7;
        color: #1B5E20;
    }
    
    .medium-badge {
        background-color: #FFE082;
        color: #FF6F00;
    }
    
    .hard-badge {
        background-color: #EF9A9A;
        color: #B71C1C;
    }
    
    .progress-container {
        margin: 1rem 0;
    }
    
    .timer-container {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 1rem;
    }
    
    .timer {
        font-size: 1.5rem;
        font-weight: bold;
        text-align: center;
        margin: 0 1rem;
        min-width: 60px;
    }
    
    .timer-critical {
        color: #B71C1C;
    }
    
    .matched-answer {
        background-color: #DCEDC8;
        border-left: 4px solid #8BC34A;
    }
    
    .unmatched-answer {
        background-color: #FFECB3;
        border-left: 4px solid #FFC107;
    }
</style>

<MudContainer>
    @if (game == null)
    {
        <MudText>No active game found. Please <MudLink Href="/">start a new game</MudLink>.</MudText>
    }
    else
    {
        <div class="game-container" style="position: relative;">
            <div class="@GetDifficultyBadgeClass()">
                @game.Difficulty.ToString()
            </div>
            
            <MudText Typo="Typo.h3" Align="Align.Center" Class="mb-4">Round @(game.CurrentRound + 1) ðŸŽ¯</MudText>
            
            <div class="progress-container">
                <MudText Typo="Typo.caption" Class="mb-1">Round progress: @(game.CurrentRound + 1)/@(game.MaxRounds)</MudText>
                <MudProgressLinear Value="@((game.CurrentRound + 1) * 100 / game.MaxRounds)" 
                                  Color="@GetProgressColor()" 
                                  Class="rounded-lg" 
                                  Striped="true" />
            </div>
            
            <div class="question-container">
                <MudText Typo="Typo.h5" Align="Align.Center" Class="mb-4">@currentQuestion</MudText>
            </div>

            @if (IsTimerActive)
            {
                <div class="timer-container flex-column"> @* Use flex-column for stacking *@
                    <div class="d-flex align-center justify-center mb-2"> @* Inner flex row for icon/text *@
                        <MudIcon Icon="@Icons.Material.Filled.Timer" Color="@GetTimerColor()" />
                        <div class="timer @(RemainingSeconds <= 5 ? "timer-critical" : "")">@RemainingSeconds</div>
                        <MudText>seconds remaining</MudText>
                    </div>
                    <MudProgressLinear Color="@GetTimerColor()" 
                                       Size="Size.Large" 
                                       Value="@GetTimerProgress()" 
                                       Class="rounded-lg" 
                                       Style="width: 80%; margin: auto;" /> @* Added progress bar *@
                </div>
            }

            @if (!kingPlayerAnswered)
            {
                <div class="answer-container">
                    <MudText Typo="Typo.h6" Class="mb-4">@game.KingPlayer!.Name's turn to answer ðŸ‘‘</MudText>
                    <MudTextField @bind-Value="@kingAnswer" 
                                Label="Your Answer" 
                                Required="true"
                                Variant="Variant.Outlined"
                                Class="mb-4" />
                    <MudButton Color="Color.Primary" 
                              Variant="Variant.Filled" 
                              OnClick="@SubmitKingAnswer" 
                              Class="mt-3"
                              StartIcon="@Icons.Material.Filled.Send">
                        Submit Answer
                    </MudButton>
                </div>
            }
            else if (showingRoundSummary && game.Questions.Count > 0)
            {
                // Use safe index calculation with bounds checking
                var prevRoundIndex = Math.Max(0, Math.Min(game.CurrentRound - 1, game.Questions.Count - 1));
                var hasPreviousRound = prevRoundIndex >= 0 && prevRoundIndex < game.Questions.Count;
                
                <div class="answer-container">
                    <MudText Typo="Typo.h5" Align="Align.Center" Class="mb-4">Round @(prevRoundIndex + 1) Summary</MudText>
                    
                    @if (hasPreviousRound)
                    {
                        <MudPaper Class="pa-3 mb-4 matched-answer">
                            <MudText Typo="Typo.subtitle1"><strong>@game.KingPlayer!.Name's Answer:</strong></MudText>
                            <MudText>@game.Questions[prevRoundIndex].KingPlayerAnswer</MudText>
                        </MudPaper>
                        
                        <MudText Typo="Typo.h6" Class="mb-2">Player Guesses:</MudText>
                        @foreach (var answer in game.Questions[prevRoundIndex].PlayerAnswers)
                        {
                            var matched = game.Questions[prevRoundIndex].HasPlayerMatched(answer.Key);
                            <MudPaper Class="@(matched ? "pa-3 mb-2 matched-answer" : "pa-3 mb-2 unmatched-answer")">
                                <MudText Typo="Typo.subtitle1">
                                    <strong>@answer.Key:</strong> 
                                    @answer.Value
                                    @if (matched)
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success" />
                                    }
                                </MudText>
                            </MudPaper>
                        }
                    }
                    else
                    {
                        <MudText Color="Color.Error">Error: Unable to display round summary. Previous round data not found.</MudText>
                    }
                    
                    <div class="d-flex justify-center mt-4">
                        <MudButton Color="Color.Primary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@ContinueToNextRound" 
                                  Class="mt-3">
                            @(game.IsGameOver ? "See Final Results" : "Continue to Next Round")
                        </MudButton>
                    </div>
                </div>
            }
            else if (showingRoundSummary)
            {
                <div class="answer-container">
                    <MudText Typo="Typo.h5" Color="Color.Error">An error occurred displaying the round summary. Starting next round...</MudText>
                    <div class="d-flex justify-center mt-4">
                        <MudButton Color="Color.Primary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@ContinueToNextRound" 
                                  Class="mt-3">
                            Continue
                        </MudButton>
                    </div>
                </div>
            }
            else
            {
                var nextPlayer = GetNextPlayerToAnswer();
                if (nextPlayer != null)
                {
                    <div class="answer-container">
                        <MudText Typo="Typo.h6" Class="mb-4">@nextPlayer.Name's turn to guess what @game.KingPlayer!.Name answered ðŸ¤”</MudText>
                        <MudTextField @bind-Value="@currentPlayerAnswer" 
                                    Label="Your Guess" 
                                    Required="true"
                                    Variant="Variant.Outlined"
                                    Class="mb-4" />
                        <MudButton Color="Color.Secondary" 
                                  Variant="Variant.Filled" 
                                  OnClick="@(() => SubmitPlayerGuess(nextPlayer.Name))" 
                                  Class="mt-3"
                                  StartIcon="@Icons.Material.Filled.Send">
                            Submit Guess
                        </MudButton>
                    </div>
                }
                else
                {
                    <div class="answer-container">
                        <MudText Align="Align.Center">All players have answered. Moving to round summary... ðŸŽ‰</MudText>
                    </div>
                }
            }

            @* Replace scoreboard div with the new component *@
            <ScoreboardDisplay GameInstance="@game" />
            
        </div>
    }
</MudContainer>

@code {
    private PoCoupleQuiz.Core.Models.Game? game;
    private string currentQuestion = "";
    private string kingAnswer = "";
    private string currentPlayerAnswer = "";
    private bool kingPlayerAnswered;
    private DateTime _roundStartTime;
    private Question? _currentQuestion;
    private List<double> _responseTimes = new();
    private Dictionary<QuestionCategory, int> _categoryStats = new();
    private List<string> _matchedAnswers = new();
    private bool showingRoundSummary = false;
    
    // Timer properties
    private Timer? _timer;
    private int RemainingSeconds { get; set; }
    private bool IsTimerActive => RemainingSeconds > 0;
    private const int KingAnswerTime = 45;  // King has more time to provide their answer
    private int PlayerAnswerTime => game?.Difficulty switch
    {
        DifficultyLevel.Easy => 40,
        DifficultyLevel.Medium => 30,
        DifficultyLevel.Hard => 20,
        _ => 30
    };

    protected override async Task OnInitializedAsync()
    {
        game = GameState.CurrentGame;
        if (game == null)
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        // Initialize game state
        game.Questions ??= new List<GameQuestion>();
        game.CurrentRound = Math.Min(game.CurrentRound, game.MaxRounds - 1);
        game.CurrentRound = Math.Max(0, game.CurrentRound);

        Logger.LogInformation("Game initialized. CurrentRound: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);

        _timer = new Timer(1000);
        _timer.Elapsed += TimerTick;

        await StartNewRound();
    }
    
    private void StartTimer(int seconds)
    {
        RemainingSeconds = seconds;
        _timer?.Start();
    }
    
    private void StopTimer()
    {
        _timer?.Stop();
        RemainingSeconds = 0;
    }
    
    private void TimerTick(object? sender, ElapsedEventArgs e)
    {
        if (RemainingSeconds <= 0)
        {
            _timer?.Stop();
            // Time's up! Use InvokeAsync to safely interact with Blazor's synchronization context
            InvokeAsync(async () => 
            {
                if (!kingPlayerAnswered)
                {
                    await HandleKingTimeoutAsync();
                }
                else
                {
                    await HandlePlayerTimeoutAsync();
                }
                StateHasChanged(); // Ensure UI updates after handling timeout
            });
        }
        else
        {
            RemainingSeconds--;
            InvokeAsync(StateHasChanged);
        }
    }
    
    // --- Refactored Timer Timeout Handlers ---
    
    private async Task HandleKingTimeoutAsync()
    {
        if (game == null) return;

        // Force submit king's answer if they have entered anything
        if (!string.IsNullOrWhiteSpace(kingAnswer))
        {
            await SubmitKingAnswer(); // Submit whatever was typed
        }
        else
        {
            // Skip this round entirely if king hasn't answered anything
            Snackbar.Add("King ran out of time! Skipping round...", Severity.Warning);
            SafeIncrementRound(); // Advance round state
            
            if (game.IsGameOver)
            {
                await EndGame(); // Navigate to game over
            }
            else
            {
                await StartNewRound(); // Start the next round
            }
        }
    }

    private async Task HandlePlayerTimeoutAsync()
    {
        if (game == null) return;

        var nextPlayer = GetNextPlayerToAnswer();
        if (nextPlayer == null) return; // Should not happen if called correctly, but safe check

        // Force submit player's guess if they have entered anything
        if (!string.IsNullOrWhiteSpace(currentPlayerAnswer))
        {
            await SubmitPlayerGuess(nextPlayer.Name); // Submit whatever was typed
        }
        else
        {
            // Skip this player's turn and record an empty answer
            Snackbar.Add($"{nextPlayer.Name} ran out of time!", Severity.Warning);
            
            EnsureCurrentQuestionExists(); // Make sure the GameQuestion object exists
            
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                var currentGameQuestion = game.Questions[currentRoundIndex];
                currentGameQuestion.RecordPlayerAnswer(nextPlayer.Name, ""); // Record empty answer for the timed-out player
                
                if (game.AllPlayersAnswered(currentRoundIndex))
                {
                    // All players have now answered (or timed out), process end of round
                    ProcessEndOfRound(); 
                }
                else
                {
                    // Move to the next player and start their timer
                    var subsequentPlayer = GetNextPlayerToAnswer();
                    if (subsequentPlayer != null)
                    {
                        StartTimer(PlayerAnswerTime);
                    }
                    // If subsequentPlayer is null here, it means the last player timed out, 
                    // and AllPlayersAnswered should have been true, leading to ProcessEndOfRound.
                }
            }
            else
            {
                // Handle unexpected invalid round index
                Logger.LogError("Invalid round index {CurrentRound} in HandlePlayerTimeoutAsync. Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
                // Attempt recovery by starting a new round
                await StartNewRound();
            }
        }
    }

    // --- End Refactored Timer Timeout Handlers ---

    private Player? GetNextPlayerToAnswer()
    {
        if (game == null) return null;
        // Use the method directly from the ScoreboardDisplay component instance if needed elsewhere,
        // or pass the necessary state down. For now, GetNextPlayerToAnswer needs this logic.
        // Let's replicate the check here temporarily until further refactoring.
        return game.Players.FirstOrDefault(p => !p.IsKingPlayer && !InternalSafeHasPlayerAnswered(p.Name));
    }

    // Removed HasPlayerAnswered as it was just a wrapper for the removed SafeHasPlayerAnswered
    
    // Replicate the check needed by GetNextPlayerToAnswer locally
    private bool InternalSafeHasPlayerAnswered(string playerName)
    {
        if (game == null) return false;
        game.Questions ??= new List<GameQuestion>();
        if (game.CurrentRound < 0 || game.CurrentRound >= game.Questions.Count)
        {
             Logger.LogWarning("InternalSafeHasPlayerAnswered: Invalid CurrentRound index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
             return false;
        }
        var currentGameQuestion = game.Questions[game.CurrentRound];
        if (game.KingPlayer?.Name == playerName) return !string.IsNullOrEmpty(currentGameQuestion.KingPlayerAnswer);
        return currentGameQuestion.HasPlayerAnswered(playerName);
    }
    
    // Removed SafeHasPlayerAnswered as it's now in ScoreboardDisplay.razor
    // private bool SafeHasPlayerAnswered(string playerName) { ... }

    private void EnsureCurrentQuestionExists()
    {
        if (game == null) return;
        
        // Ensure Questions list is initialized
        game.Questions ??= new List<GameQuestion>();
        
        // Make sure current round is in bounds
        game.CurrentRound = Math.Max(0, Math.Min(game.CurrentRound, game.MaxRounds - 1));
        
        // Add questions if needed to match the current round
        while (game.CurrentRound >= game.Questions.Count)
        {
            game.Questions.Add(new GameQuestion { Question = currentQuestion });
            Logger.LogWarning("Added missing question for round {RoundIndex}. Questions count now: {QuestionsCount}", game.Questions.Count - 1, game.Questions.Count);
        }
    }

    private async Task StartNewRound()
    {
        if (game == null) return;

        // Reset round state
        showingRoundSummary = false;
        kingPlayerAnswered = false;
        kingAnswer = "";
        currentPlayerAnswer = "";
        _roundStartTime = DateTime.UtcNow;
        
        // Ensure current round is within valid bounds
        game.CurrentRound = Math.Max(0, Math.Min(game.CurrentRound, game.MaxRounds - 1));

        Logger.LogInformation("Starting round {CurrentRoundPlusOne}/{MaxRounds}", game.CurrentRound + 1, game.MaxRounds); // Corrected syntax

        // Ensure we have a GameQuestion object for the current round
        EnsureCurrentQuestionExists();
        
        // Generate question based on difficulty
        try 
        {
            // GenerateQuestionAsync now returns a Question object
            _currentQuestion = game.Difficulty switch
            {
                DifficultyLevel.Easy => await QuestionService.GenerateQuestionAsync("easy"),
                DifficultyLevel.Hard => await QuestionService.GenerateQuestionAsync("hard"),
                _ => await QuestionService.GenerateQuestionAsync()
            };
            
            // Use the Text property for display
            currentQuestion = _currentQuestion.Text; 
            Logger.LogInformation("Generated question for round {CurrentRoundPlusOne}: {QuestionText} (Category: {Category})", game.CurrentRound + 1, currentQuestion, _currentQuestion.Category);
            
            // Update the question text for this round in the game state
            game.Questions[game.CurrentRound].Question = currentQuestion;
            // Note: GameQuestion model doesn't store Category yet. This could be a future enhancement.

            // Update category statistics using the Category from the returned Question object
            _categoryStats ??= new Dictionary<QuestionCategory, int>(); // Initialize if null
            if (_categoryStats.ContainsKey(_currentQuestion.Category))
            {
                _categoryStats[_currentQuestion.Category]++;
            }
            else
            {
                _categoryStats[_currentQuestion.Category] = 1;
            }
            Logger.LogInformation("Updated category stats for {Category}. Current stats: {StatsJson}", _currentQuestion.Category, JsonSerializer.Serialize(_categoryStats));

            // Start the timer for king's answer
            StartTimer(KingAnswerTime);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error generating question in StartNewRound");
            Snackbar.Add("Error generating question. Using a default question.", Severity.Warning);
            
            // Use a fallback question (QuestionService now returns a Question object on fallback)
            _currentQuestion = await QuestionService.GenerateQuestionAsync(); // Call again to get fallback Question object
            currentQuestion = _currentQuestion.Text;
            game.Questions[game.CurrentRound].Question = currentQuestion;
            
            // Update stats even for fallback question
            _categoryStats ??= new Dictionary<QuestionCategory, int>();
            if (_categoryStats.ContainsKey(_currentQuestion.Category)) _categoryStats[_currentQuestion.Category]++; else _categoryStats[_currentQuestion.Category] = 1;
            Logger.LogInformation("Updated category stats for fallback question {Category}. Current stats: {StatsJson}", _currentQuestion.Category, JsonSerializer.Serialize(_categoryStats));

            // Start the timer for king's answer
            StartTimer(KingAnswerTime);
        }

        StateHasChanged();
    }

    private async Task SubmitKingAnswer()
    {
        if (game == null || string.IsNullOrWhiteSpace(kingAnswer)) return;

        // Stop the timer
        StopTimer();

        // Ensure the current game question exists
        EnsureCurrentQuestionExists();
        
        var currentGameQuestion = game.Questions[game.CurrentRound];
        currentGameQuestion.KingPlayerAnswer = kingAnswer;
        kingPlayerAnswered = true;
        Snackbar.Add("Answer submitted!", Severity.Success);
        
        var nextPlayer = GetNextPlayerToAnswer();
        if (nextPlayer != null)
        {
            // Start timer for first player's guess
            StartTimer(PlayerAnswerTime);
        }
        
        StateHasChanged();
    }

    private async Task SubmitPlayerGuess(string playerName)
    {
        if (game == null || _currentQuestion == null) return;

        // Stop the timer
        StopTimer();

        var responseTime = (DateTime.UtcNow - _roundStartTime).TotalSeconds;
        _responseTimes.Add(responseTime);

        // Ensure the current game question exists
        EnsureCurrentQuestionExists();

        var currentGameQuestion = game.Questions[game.CurrentRound];
        
        // Record the player's answer
        currentGameQuestion.RecordPlayerAnswer(playerName, currentPlayerAnswer);
        
        // Check if the answer matches the king's answer
        // First do a simple case-insensitive check
        bool isMatch = string.Equals(currentPlayerAnswer, currentGameQuestion.KingPlayerAnswer, StringComparison.OrdinalIgnoreCase);
        
        // If not an exact match, try semantic similarity check with OpenAI
        if (!isMatch && !string.IsNullOrWhiteSpace(currentPlayerAnswer) && !string.IsNullOrWhiteSpace(currentGameQuestion.KingPlayerAnswer))
        {
            try
            {
                // Use AI to check for semantic similarity
                isMatch = await QuestionService.CheckAnswerSimilarityAsync(currentGameQuestion.KingPlayerAnswer, currentPlayerAnswer);
                Logger.LogInformation("Semantic similarity check for '{PlayerAnswer}' against '{KingAnswer}': {IsMatch}", currentPlayerAnswer, currentGameQuestion.KingPlayerAnswer, isMatch);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error checking answer similarity for '{PlayerAnswer}' vs '{KingAnswer}'. Falling back to simple comparison.", currentPlayerAnswer, currentGameQuestion.KingPlayerAnswer);
                
                // Fallback to simple contains check if API fails
                isMatch = currentPlayerAnswer.ToLowerInvariant().Contains(currentGameQuestion.KingPlayerAnswer.ToLowerInvariant()) || 
                         currentGameQuestion.KingPlayerAnswer.ToLowerInvariant().Contains(currentPlayerAnswer.ToLowerInvariant());
            }
        }
        
        // If the answers match, mark the player as having a match
        if (isMatch)
        {
            currentGameQuestion.MarkPlayerAsMatched(playerName);
            Logger.LogInformation("Player {PlayerName}'s answer matches! Marked as matched.", playerName);
            Snackbar.Add("Good guess! That matches the king's answer!", Severity.Success);
        }
        else
        {
            Logger.LogInformation("Player {PlayerName}'s answer does not match.", playerName);
            Snackbar.Add("Submitted your guess!", Severity.Info);
        }
        
        currentPlayerAnswer = "";
        StateHasChanged();

        // Check if all players have answered
        var allPlayersAnswered = game.AllPlayersAnswered(game.CurrentRound);
        if (allPlayersAnswered)
        {
            ProcessEndOfRound(); // Don't await void/synchronous logic
        }
        else
        {
            var nextPlayer = GetNextPlayerToAnswer();
            if (nextPlayer != null)
            {
                // Start timer for next player's guess
                StartTimer(PlayerAnswerTime);
            }
        }
    }
    
    private async Task ProcessEndOfRound() // Revert signature back to async Task
    {
        if (game == null) return; // Keep return for early exit
        
        try
        {
            // Ensure the current round is valid
            var currentRoundIndex = Math.Min(game.CurrentRound, game.Questions.Count - 1);
            if (currentRoundIndex >= 0 && currentRoundIndex < game.Questions.Count)
            {
                game.UpdateScores(currentRoundIndex);
                
                // Show round summary instead of immediately proceeding
                showingRoundSummary = true;
                
                // Capture matched answers for statistics
                var currentGameQuestion = game.Questions[currentRoundIndex];
                foreach (var player in currentGameQuestion.PlayersMatched)
                {
                    _matchedAnswers.Add($"{player}:{currentGameQuestion.Question}");
                }
            }
            else
            {
                Logger.LogError("Error in ProcessEndOfRound: Invalid round index: {CurrentRound}, Questions count: {QuestionsCount}", game.CurrentRound, game.Questions.Count);
                // Still proceed to show summary screen
                showingRoundSummary = true;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing end of round: {ErrorMessage}", ex.Message);
            // Still proceed to show summary screen
            showingRoundSummary = true;
        }
        
        StateHasChanged();
        // No Task.CompletedTask needed here as it's implicitly returned for async Task
    }
    
    private async Task SafeIncrementRound() // Revert signature back to async Task
    {
        if (game == null) return; // Keep return for early exit
        
        // Increment round with bounds checking
        game.CurrentRound++;
        
        // Ensure within max bounds
        if (game.CurrentRound >= game.MaxRounds)
        {
            game.CurrentRound = game.MaxRounds;
        }
        
        // Log the round transition for debugging
        Logger.LogInformation("Moving to round {CurrentRoundPlusOne}. Total questions: {QuestionsCount}, Max rounds: {MaxRounds}", game.CurrentRound + 1, game.Questions.Count, game.MaxRounds);
    }
    
    private async Task ContinueToNextRound()
    {
        if (game == null) return;
        
        // Increment round safely
        SafeIncrementRound();
        
        if (game.IsGameOver)
        {
            await EndGame();
        }
        else
        {
            await StartNewRound();
        }
    }
    
    private async Task EndGame()
    {
        // Add explicit null checks for game and KingPlayer
        if (game == null || game.KingPlayer == null) 
        {
            Logger.LogError("Error in EndGame: Game or KingPlayer is null. Cannot proceed.");
            // Optionally navigate to an error page or home page
            NavigationManager.NavigateTo("/"); 
            return;
        }
        
        // Save game history
        var history = new GameHistory
        {
            Team1Name = game.KingPlayer!.Name,
            Team2Name = "Multiple Players",
            GameMode = GameMode.KingPlayer,
            Team1Score = game.Players.Max(p => p.Score),
            TotalQuestions = Math.Min(game.CurrentRound, game.Questions.Count),
            AverageResponseTime = _responseTimes.Count > 0 ? _responseTimes.Average() : 0,
            CategoryStats = JsonSerializer.Serialize(_categoryStats),
            MatchedAnswers = JsonSerializer.Serialize(_matchedAnswers)
        };
        await GameHistoryService.SaveGameHistoryAsync(history);

        // Save player stats cumulatively
        foreach (var player in game.Players)
        {
            // Fetch existing team/player data
            var existingTeam = await TeamService.GetTeamAsync(player.Name);
            
            Team teamToSave;
            int questionsThisGame = Math.Min(game.CurrentRound, game.Questions.Count);
            bool wonThisGame = player.Score > 0 && player == game.Players.OrderByDescending(p => p.Score).First(); // Check if this player is the winner

            if (existingTeam != null)
            {
                // Update existing team stats
                teamToSave = existingTeam;
                teamToSave.MultiplayerWins += wonThisGame ? 1 : 0;
                teamToSave.TotalQuestionsAnswered += questionsThisGame;
                teamToSave.CorrectAnswers += player.TotalCorrectGuesses; // Assuming TotalCorrectGuesses is for the current game only
                teamToSave.LastPlayed = DateTime.UtcNow;
            }
            else
            {
                // Create new team stats
                teamToSave = new Team 
                { 
                    Name = player.Name,
                    MultiplayerWins = wonThisGame ? 1 : 0,
                    TotalQuestionsAnswered = questionsThisGame,
                    CorrectAnswers = player.TotalCorrectGuesses,
                    LastPlayed = DateTime.UtcNow
                    // SinglePlayerHighScore remains default 0
                };
            }
            
            await TeamService.SaveTeamAsync(teamToSave);
            Logger.LogInformation("Saved stats for player {PlayerName}: Wins={Wins}, Questions={Questions}, Correct={Correct}", player.Name, teamToSave.MultiplayerWins, teamToSave.TotalQuestionsAnswered, teamToSave.CorrectAnswers);
        }

        GameState.ClearGame();
        var winner = game.Players.OrderByDescending(p => p.Score).First();
        var scores = string.Join("|", game.GetScoreboard().Select(s => $"{s.Key}:{s.Value}"));
        NavigationManager.NavigateTo($"/game-over/king/{game.KingPlayer!.Name}/{winner.Name}/{winner.Score}/{Uri.EscapeDataString(scores)}");
        return;
    }

    private string GetDifficultyBadgeClass() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => "difficulty-badge easy-badge",
        DifficultyLevel.Medium => "difficulty-badge medium-badge",
        DifficultyLevel.Hard => "difficulty-badge hard-badge",
        _ => "difficulty-badge medium-badge"
    };
    
    private Color GetProgressColor() => game?.Difficulty switch
    {
        DifficultyLevel.Easy => Color.Success,
        DifficultyLevel.Medium => Color.Warning,
        DifficultyLevel.Hard => Color.Error,
        _ => Color.Warning
    };
    
    // --- Timer UI Helper Methods ---
    
    private double GetTimerProgress()
    {
        if (!IsTimerActive) return 0;
        
        int totalTime = kingPlayerAnswered ? PlayerAnswerTime : KingAnswerTime;
        if (totalTime <= 0) return 0; // Avoid division by zero
        
        // Calculate progress percentage (invert so it depletes)
        double progress = ((double)RemainingSeconds / totalTime) * 100.0;
        return Math.Max(0, Math.Min(100, progress)); // Clamp between 0 and 100
    }

    private Color GetTimerColor()
    {
        if (!IsTimerActive) return Color.Default;
        
        int totalTime = kingPlayerAnswered ? PlayerAnswerTime : KingAnswerTime;
        double percentage = GetTimerProgress();

        if (percentage <= 15) return Color.Error; // Last 15% is red
        if (percentage <= 40) return Color.Warning; // Below 40% is yellow
        return Color.Success; // Otherwise green
    }

    // --- End Timer UI Helper Methods ---

    public void Dispose()
    {
        if (_timer != null)
        {
            _timer.Elapsed -= TimerTick;
            _timer.Dispose();
        }
    }
}
